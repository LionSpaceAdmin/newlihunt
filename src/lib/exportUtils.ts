import { FullAnalysisResult, Message } from '@/types/analysis';
import { formatDate, formatTimestamp, copyToClipboard as utilsCopyToClipboard } from '@/utils/helpers';

export interface ExportOptions {
  includeConversation?: boolean;
  includeTimestamp?: boolean;
  includeMetadata?: boolean;
  privacy?: 'full' | 'anonymized' | 'minimal';
  format?: 'text' | 'json' | 'social';
}

export interface PrivacyCheck {
  safe: boolean;
  warnings: string[];
  recommendations: string[];
}

/**
 * Generate a text report from analysis results
 */
export function generateTextReport(
  analysis: FullAnalysisResult,
  conversation?: Message[],
  options: ExportOptions = {}
): string {
  const {
    includeConversation = false,
    includeTimestamp = true,
    includeMetadata = false,
    privacy = 'anonymized',
  } = options;

  let report = '';

  // Header
  report += 'ü¶Å SCAM HUNTER ANALYSIS REPORT\n';
  report += '================================\n\n';

  // Timestamp
  if (includeTimestamp) {
    const date = new Date(analysis.metadata.timestamp);
    report += `Generated: ${formatDate(date)} at ${formatTimestamp(date)}\n\n`;
  }

  // Summary
  report += 'SUMMARY\n';
  report += '-------\n';
  report += `${analysis.summary}\n\n`;

  // Scores and Classification
  report += 'ASSESSMENT SCORES\n';
  report += '-----------------\n';
  report += `Risk Score: ${analysis.analysisData.riskScore}/100\n`;
  report += `Credibility Score: ${analysis.analysisData.credibilityScore}/100\n`;
  report += `Classification: ${analysis.analysisData.classification}\n\n`;

  // Detected Rules
  if (analysis.analysisData.detectedRules.length > 0) {
    report += 'DETECTED INDICATORS\n';
    report += '-------------------\n';
    analysis.analysisData.detectedRules.forEach((rule, index) => {
      report += `${index + 1}. ${rule.name} (${rule.severity})\n`;
      report += `   Points: ${rule.points > 0 ? '+' : ''}${rule.points}\n`;
      report += `   ${rule.description}\n\n`;
    });
  }

  // Recommendations
  report += 'RECOMMENDATIONS\n';
  report += '---------------\n';
  analysis.analysisData.recommendations.forEach((rec, index) => {
    report += `${index + 1}. ${rec}\n`;
  });
  report += '\n';

  // Reasoning
  report += 'DETAILED REASONING\n';
  report += '------------------\n';
  report += `${analysis.analysisData.reasoning}\n\n`;

  // Conversation (if requested and privacy allows)
  if (includeConversation && conversation && privacy !== 'minimal') {
    report += 'CONVERSATION HISTORY\n';
    report += '--------------------\n';
    conversation.forEach((message, index) => {
      const time = formatTimestamp(message.timestamp);
      const role = message.role === 'user' ? 'USER' : 'SCAM HUNTER';
      report += `[${time}] ${role}: ${sanitizeForExport(message.content, privacy)}\n`;
      if (message.imageUrl && privacy === 'full') {
        report += `    [Image attached]\n`;
      }
    });
    report += '\n';
  }

  // Metadata (if requested)
  if (includeMetadata) {
    report += 'TECHNICAL METADATA\n';
    report += '------------------\n';
    report += `Version: ${analysis.metadata.version || 'Unknown'}\n`;
    report += `Processing Time: ${analysis.metadata.processingTime || 0}ms\n`;
    
    // Debiasing status
    report += '\nDebiasing Status:\n';
    report += `- Anonymous Profile Neutralized: ${analysis.analysisData.debiasingStatus.anonymous_profile_neutralized ? 'Yes' : 'No'}\n`;
    report += `- Patriotic Tokens Neutralized: ${analysis.analysisData.debiasingStatus.patriotic_tokens_neutralized ? 'Yes' : 'No'}\n`;
    report += `- Sentiment Penalty Capped: ${analysis.analysisData.debiasingStatus.sentiment_penalty_capped ? 'Yes' : 'No'}\n`;
  }

  // Footer
  report += '\n---\n';
  report += 'Generated by Scam Hunter - AI-Powered Scam Detection\n';
  report += 'For verified donations, visit: https://www.fidf.org/donate\n';
  report += 'Report issues or false positives to improve our detection.\n';

  return report;
}

/**
 * Generate JSON export of analysis results
 */
export function generateJSONReport(
  analysis: FullAnalysisResult,
  conversation?: Message[],
  options: ExportOptions = {}
): string {
  const {
    includeConversation = false,
    includeMetadata = true,
    privacy = 'anonymized',
  } = options;

  const exportData: Record<string, unknown> = {
    exportInfo: {
      generatedAt: new Date().toISOString(),
      version: '1.0',
      privacy: privacy,
      source: 'Scam Hunter Analysis Platform',
    },
    analysis: {
      summary: analysis.summary,
      scores: {
        risk: analysis.analysisData.riskScore,
        credibility: analysis.analysisData.credibilityScore,
        classification: analysis.analysisData.classification,
      },
      detectedRules: analysis.analysisData.detectedRules,
      recommendations: analysis.analysisData.recommendations,
      reasoning: analysis.analysisData.reasoning,
    },
  };

  if (includeMetadata) {
    exportData.metadata = {
      timestamp: analysis.metadata.timestamp,
      processingTime: analysis.metadata.processingTime,
      version: analysis.metadata.version,
      debiasingStatus: analysis.analysisData.debiasingStatus,
    };
  }

  if (includeConversation && conversation && privacy !== 'minimal') {
    exportData.conversation = conversation.map(msg => ({
      role: msg.role,
      content: sanitizeForExport(msg.content, privacy),
      timestamp: msg.timestamp.toISOString(),
      hasImage: !!msg.imageUrl,
    }));
  }

  return JSON.stringify(exportData, null, 2);
}

/**
 * Generate social media friendly summary
 */
export function generateSocialSummary(analysis: FullAnalysisResult): string {
  const { riskScore, classification } = analysis.analysisData;
  
  let emoji = 'üü°';
  let status = 'SUSPICIOUS';
  
  if (classification === 'SAFE') {
    emoji = 'üü¢';
    status = 'SAFE';
  } else if (classification === 'HIGH_RISK') {
    emoji = 'üî¥';
    status = 'HIGH RISK';
  }

  let summary = `ü¶Å SCAM HUNTER ANALYSIS ${emoji}\n\n`;
  summary += `Status: ${status}\n`;
  summary += `Risk Score: ${riskScore}/100\n\n`;
  
  // Add key findings (first 2 recommendations)
  if (analysis.analysisData.recommendations.length > 0) {
    summary += 'Key Findings:\n';
    analysis.analysisData.recommendations.slice(0, 2).forEach((rec, index) => {
      summary += `${index + 1}. ${rec}\n`;
    });
  }
  
  summary += '\nüõ°Ô∏è Stay safe online!\n';
  summary += 'üáÆüá± For verified IDF donations: fidf.org\n';
  summary += '\n#ScamHunter #OnlineSafety #Israel';

  return summary;
}

/**
 * Download text report as file
 */
export function downloadTextReport(
  analysis: FullAnalysisResult,
  conversation?: Message[],
  options: ExportOptions = {}
): void {
  const report = generateTextReport(analysis, conversation, options);
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const filename = `scam-hunter-report-${timestamp}.txt`;
  
  downloadFile(report, filename, 'text/plain');
}

/**
 * Download JSON report as file
 */
export function downloadJSONReport(
  analysis: FullAnalysisResult,
  conversation?: Message[],
  options: ExportOptions = {}
): void {
  const report = generateJSONReport(analysis, conversation, options);
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const filename = `scam-hunter-analysis-${timestamp}.json`;
  
  downloadFile(report, filename, 'application/json');
}

/**
 * Copy analysis to clipboard
 */
export async function copyToClipboard(
  analysis: FullAnalysisResult,
  format: 'summary' | 'full' | 'social' = 'summary',
  conversation?: Message[]
): Promise<boolean> {
  try {
    let content = '';
    
    switch (format) {
      case 'summary':
        content = analysis.summary;
        break;
      case 'social':
        content = generateSocialSummary(analysis);
        break;
      case 'full':
        content = generateTextReport(analysis, conversation, {
          includeConversation: true,
          includeTimestamp: true,
          privacy: 'anonymized',
        });
        break;
    }
    
    return await utilsCopyToClipboard(content);
  } catch (error) {
    console.error('Failed to copy to clipboard:', error);
    return false;
  }
}

/**
 * Share analysis using native sharing API
 */
export async function shareAnalysis(analysis: FullAnalysisResult): Promise<boolean> {
  if (typeof window === 'undefined' || !navigator.share) {
    return false;
  }

  try {
    const summary = generateSocialSummary(analysis);
    
    await navigator.share({
      title: 'Scam Hunter Analysis Results',
      text: summary,
      url: window.location.href,
    });
    
    return true;
  } catch (error) {
    console.error('Failed to share:', error);
    return false;
  }
}

/**
 * Validate content for privacy before sharing
 */
export function validateSharingPrivacy(
  analysis: FullAnalysisResult,
  conversation?: Message[]
): PrivacyCheck {
  const warnings: string[] = [];
  const recommendations: string[] = [];

  // Check for potentially sensitive content in analysis
  const allText = [
    analysis.summary,
    analysis.analysisData.reasoning,
    ...analysis.analysisData.recommendations,
  ].join(' ').toLowerCase();

  // Check for personal information patterns
  if (allText.match(/\b\d{3}-\d{2}-\d{4}\b/)) {
    warnings.push('Potential SSN detected');
  }
  
  if (allText.match(/\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/)) {
    warnings.push('Email addresses detected');
  }
  
  if (allText.match(/\b\d{3}-\d{3}-\d{4}\b/)) {
    warnings.push('Phone numbers detected');
  }

  // Check conversation for sensitive content
  if (conversation) {
    const conversationText = conversation
      .map(msg => msg.content)
      .join(' ')
      .toLowerCase();
      
    if (conversationText.match(/password|pin|ssn|social security/)) {
      warnings.push('Sensitive information in conversation');
    }
  }

  // Generate recommendations
  if (warnings.length > 0) {
    recommendations.push('Review content before sharing publicly');
    recommendations.push('Consider using anonymized export options');
    recommendations.push('Remove or redact sensitive information');
  }

  return {
    safe: warnings.length === 0,
    warnings,
    recommendations,
  };
}

/**
 * Sanitize content for export based on privacy level
 */
function sanitizeForExport(content: string, privacy: 'full' | 'anonymized' | 'minimal'): string {
  if (privacy === 'full') {
    return content;
  }

  let sanitized = content;

  if (privacy === 'anonymized' || privacy === 'minimal') {
    // Remove email addresses
    sanitized = sanitized.replace(/\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g, '[EMAIL_REDACTED]');
    
    // Remove phone numbers
    sanitized = sanitized.replace(/\b\d{3}-\d{3}-\d{4}\b/g, '[PHONE_REDACTED]');
    
    // Remove potential SSNs
    sanitized = sanitized.replace(/\b\d{3}-\d{2}-\d{4}\b/g, '[SSN_REDACTED]');
    
    // Remove URLs (keep domain only)
    sanitized = sanitized.replace(/https?:\/\/[^\s]+/g, (match) => {
      try {
        const url = new URL(match);
        return `[URL: ${url.hostname}]`;
      } catch {
        return '[URL_REDACTED]';
      }
    });
  }

  if (privacy === 'minimal') {
    // Further sanitization for minimal privacy
    sanitized = sanitized.replace(/\b[A-Z][a-z]+ [A-Z][a-z]+\b/g, '[NAME_REDACTED]');
  }

  return sanitized;
}

/**
 * Helper function to download file
 */
function downloadFile(content: string, filename: string, mimeType: string): void {
  if (typeof window === 'undefined') return;

  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  link.style.display = 'none';
  
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  
  URL.revokeObjectURL(url);
}