/**
 * Export utilities for generating shareable analysis reports
 */

import { FullAnalysisResult, Message } from '@/types/analysis';

export interface ExportOptions {
  includeConversation?: boolean;
  includeTimestamp?: boolean;
  format?: 'text' | 'json' | 'pdf';
  privacy?: 'full' | 'anonymized';
}

export interface ShareableReport {
  id: string;
  timestamp: string;
  analysis: FullAnalysisResult;
  conversation?: Message[];
  summary: string;
  url?: string;
}

/**
 * Generates a shareable text report from analysis results
 */
export function generateTextReport(
  analysis: FullAnalysisResult,
  conversation?: Message[],
  options: ExportOptions = {}
): string {
  const { includeConversation = false, includeTimestamp = true, privacy = 'anonymized' } = options;
  
  let report = '';
  
  // Header
  report += 'üõ°Ô∏è SCAM HUNTER ANALYSIS REPORT\n';
  report += '=' .repeat(40) + '\n\n';
  
  if (includeTimestamp) {
    report += `üìÖ Analysis Date: ${new Date().toLocaleString()}\n`;
    report += `üîó Generated by: Scam Hunter Platform\n\n`;
  }
  
  // Risk Assessment
  report += 'üìä RISK ASSESSMENT\n';
  report += '-'.repeat(20) + '\n';
  report += `üéØ Risk Score: ${analysis.analysisData.riskScore}/100\n`;
  report += `‚úÖ Credibility Score: ${analysis.analysisData.credibilityScore}/100\n`;
  report += `üè∑Ô∏è Classification: ${analysis.analysisData.classification}\n\n`;
  
  // Risk Factors
  if (analysis.analysisData.detectedRules && analysis.analysisData.detectedRules.length > 0) {
    report += '‚ö†Ô∏è DETECTED RISK FACTORS\n';
    report += '-'.repeat(25) + '\n';
    analysis.analysisData.detectedRules.forEach((rule, index) => {
      const severityIcon = rule.severity === 'HIGH' ? 'üö®' : 
                          rule.severity === 'MEDIUM' ? '‚ö†Ô∏è' : '‚ö°';
      report += `${index + 1}. ${severityIcon} ${rule.name} (${rule.severity})\n`;
      if (rule.description) {
        report += `   ${rule.description}\n`;
      }
      report += `   Points: ${rule.points}\n\n`;
    });
  }
  
  // Recommendations
  if (analysis.analysisData.recommendations && analysis.analysisData.recommendations.length > 0) {
    report += 'üí° RECOMMENDATIONS\n';
    report += '-'.repeat(17) + '\n';
    analysis.analysisData.recommendations.forEach((rec, index) => {
      report += `${index + 1}. ${rec}\n`;
    });
    report += '\n';
  }
  
  // AI Reasoning
  if (analysis.analysisData.reasoning) {
    report += 'ü§ñ AI ANALYSIS REASONING\n';
    report += '-'.repeat(24) + '\n';
    report += `${analysis.analysisData.reasoning}\n\n`;
  }
  
  // Conversation History (if requested and privacy allows)
  if (includeConversation && conversation && privacy === 'full') {
    report += 'üí¨ CONVERSATION HISTORY\n';
    report += '-'.repeat(23) + '\n';
    conversation.forEach((message, index) => {
      const role = message.role === 'user' ? 'üë§ User' : 'ü§ñ Scam Hunter';
      report += `${role}: ${message.content}\n`;
      if (message.imageUrl) {
        report += `   üìé Image: ${message.imageUrl}\n`;
      }
      report += `   ‚è∞ ${new Date(message.timestamp).toLocaleString()}\n\n`;
    });
  }
  
  // Footer
  report += '=' .repeat(40) + '\n';
  report += 'üõ°Ô∏è Stay safe online! Always verify suspicious content.\n';
  report += 'üåê Visit our platform for more security tools.\n';
  
  return report;
}

/**
 * Generates a JSON export of the analysis
 */
export function generateJSONReport(
  analysis: FullAnalysisResult,
  conversation?: Message[],
  options: ExportOptions = {}
): string {
  const { includeConversation = false, includeTimestamp = true, privacy = 'anonymized' } = options;
  
  const report: any = {
    platform: 'Scam Hunter',
    version: '1.0',
    analysis: {
      riskScore: analysis.analysisData.riskScore,
      credibilityScore: analysis.analysisData.credibilityScore,
      classification: analysis.analysisData.classification,
      detectedRules: analysis.analysisData.detectedRules,
      recommendations: analysis.analysisData.recommendations,
      reasoning: privacy === 'full' ? analysis.analysisData.reasoning : '[Reasoning hidden for privacy]'
    }
  };
  
  if (includeTimestamp) {
    report.timestamp = new Date().toISOString();
  }
  
  if (includeConversation && conversation && privacy === 'full') {
    report.conversation = conversation.map(msg => ({
      role: msg.role,
      content: msg.content,
      timestamp: msg.timestamp,
      hasImage: !!msg.imageUrl
    }));
  }
  
  return JSON.stringify(report, null, 2);
}

/**
 * Creates a shareable summary for social media
 */
export function generateSocialSummary(analysis: FullAnalysisResult): string {
  const riskLevel = analysis.analysisData.riskScore >= 70 ? 'HIGH RISK' :
                   analysis.analysisData.riskScore >= 40 ? 'MODERATE RISK' : 'LOW RISK';
  
  const emoji = analysis.analysisData.riskScore >= 70 ? 'üö®' :
               analysis.analysisData.riskScore >= 40 ? '‚ö†Ô∏è' : '‚úÖ';
  
  return `${emoji} Scam Analysis Result: ${riskLevel}
Risk Score: ${analysis.analysisData.riskScore}/100
Credibility: ${analysis.analysisData.credibilityScore}/100

üõ°Ô∏è Analyzed by Scam Hunter - AI-powered scam detection
#ScamPrevention #OnlineSafety #CyberSecurity`;
}

/**
 * Downloads a text file with the analysis report
 */
export function downloadTextReport(
  analysis: FullAnalysisResult,
  conversation?: Message[],
  options: ExportOptions = {}
): void {
  const report = generateTextReport(analysis, conversation, options);
  const blob = new Blob([report], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  
  const link = document.createElement('a');
  link.href = url;
  link.download = `scam-analysis-${Date.now()}.txt`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

/**
 * Downloads a JSON file with the analysis report
 */
export function downloadJSONReport(
  analysis: FullAnalysisResult,
  conversation?: Message[],
  options: ExportOptions = {}
): void {
  const report = generateJSONReport(analysis, conversation, options);
  const blob = new Blob([report], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  
  const link = document.createElement('a');
  link.href = url;
  link.download = `scam-analysis-${Date.now()}.json`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

/**
 * Copies analysis summary to clipboard
 */
export async function copyToClipboard(
  analysis: FullAnalysisResult,
  format: 'summary' | 'social' | 'full' = 'summary'
): Promise<boolean> {
  try {
    let text = '';
    
    switch (format) {
      case 'social':
        text = generateSocialSummary(analysis);
        break;
      case 'full':
        text = generateTextReport(analysis, undefined, { privacy: 'anonymized' });
        break;
      default:
        text = `üõ°Ô∏è Scam Analysis: Risk ${analysis.analysisData.riskScore}/100, Credibility ${analysis.analysisData.credibilityScore}/100, Classification: ${analysis.analysisData.classification}`;
    }
    
    await navigator.clipboard.writeText(text);
    return true;
  } catch (error) {
    console.error('Failed to copy to clipboard:', error);
    return false;
  }
}

/**
 * Shares analysis via Web Share API (mobile-friendly)
 */
export async function shareAnalysis(
  analysis: FullAnalysisResult,
  options: { title?: string; text?: string; url?: string } = {}
): Promise<boolean> {
  if (!navigator.share) {
    return false; // Web Share API not supported
  }
  
  try {
    const defaultTitle = 'üõ°Ô∏è Scam Hunter Analysis Result';
    const defaultText = generateSocialSummary(analysis);
    
    await navigator.share({
      title: options.title || defaultTitle,
      text: options.text || defaultText,
      url: options.url
    });
    
    return true;
  } catch (error) {
    console.error('Failed to share:', error);
    return false;
  }
}

/**
 * Generates a privacy-safe shareable link (placeholder for future implementation)
 */
export function generateShareableLink(analysis: FullAnalysisResult): string {
  // This would typically involve creating a secure, temporary link
  // For now, return a placeholder
  const analysisId = `analysis_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  return `${window.location.origin}/shared/${analysisId}`;
}

/**
 * Validates if sharing is safe (no sensitive information)
 */
export function validateSharingPrivacy(
  analysis: FullAnalysisResult,
  conversation?: Message[]
): { safe: boolean; warnings: string[] } {
  const warnings: string[] = [];
  
  // Check for potentially sensitive information
  if (conversation) {
    const hasPersonalInfo = conversation.some(msg => 
      /\b\d{3}-\d{2}-\d{4}\b|\b\d{4}\s?\d{4}\s?\d{4}\s?\d{4}\b|[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/
        .test(msg.content)
    );
    
    if (hasPersonalInfo) {
      warnings.push('Conversation may contain personal information (SSN, credit card, email)');
    }
    
    const hasImages = conversation.some(msg => msg.imageUrl);
    if (hasImages) {
      warnings.push('Conversation contains uploaded images');
    }
  }
  
  return {
    safe: warnings.length === 0,
    warnings
  };
}